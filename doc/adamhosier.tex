I was mainly involved in creating the assembler part with Pontus. I built the main structure for the assembler, including file I/O, data-structures to handle the different instruction types, and some of the instruction specific functions to translate them to binary. I consider myself a comparatively fluent programmer in the group, so I was able to help and guide other members in completing their own sections. 

We decided to follow the two-pass assembly method described in the specification. First the ARM assembly file is read in to memory line-by-line. Each line has comments and white-space stripped from it, and if the line is recognised as a label, it is added to the symbol table and ignored. The symbol table is stored using a linked list of symbol structs with methods written to search, add and free an element from this list. The second pass then takes each instruction again, and tokenises its arguments. It looks up the first argument (the instruction mnemonic) in a Map-like data structure, which returns a pointer to a function that can deal with that instruction. The tokenised arguments, as well as other relevant data are passed to this function, which returns a struct holding each part of the instruction as binary. Finally this struct is passed to the encoder, which converts it to the 32-bit binary instruction, which can be written to output.